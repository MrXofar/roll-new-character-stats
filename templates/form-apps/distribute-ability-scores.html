<form>
    <script>
        /* global CONFIG */
        function Intitialize() {

            // Apply as Rolled?
            const ability_scores = document.getElementById("ability_scores");
            if (ability_scores.dataset.hideresultszone === "true") { document.getElementById("results-table")?.classList.add("display_none"); }
            if (ability_scores.dataset.distributeresults === "false") { ApplyAsRolled(); }

            // Game System Specific Configuration
            switch (game.system.id) {

                case "ose":
                case "archmage":
                    HideRaceOptions();
                    break;
                case "dcc":
                    HideRaceOptions();
                    let occupation = document.getElementById("occupation");
                    occupation.innerHTML = occupation.dataset.occupation;
                    break;

                default:
                    break;
            }
        }

        function HideRaceOptions() {
            // Hide Race selector and Race Bonus column            
            document.getElementById("race-selector")?.classList.add("display_none");
            ability_scores.querySelector(".header-row").querySelector(".race-mod-header")?.classList.add("display_none");
            const ability_rows = ability_scores.querySelectorAll(".ability-row")
            for (let row = 0; row < ability_rows.length; row += 1) {
                const ability_row = document.getElementById(ability_rows[row].id);
                ability_row.querySelector(".racial-mod")?.classList.add("display_none");
            }
        }

        function HideAbilityModifierColumn() {
            ability_scores.querySelector(".header-row").querySelector(".modifier-header")?.classList.add("display_none");
            const ability_rows = ability_scores.querySelectorAll(".ability-row")
            for (let row = 0; row < ability_rows.length; row += 1) {
                const ability_row = document.getElementById(ability_rows[row].id);
                ability_row.querySelector(".modifier")?.classList.add("display_none");
            }
        }

        function dragover_handler(ev) {
            ev.preventDefault();
            ev.dataTransfer.dropEffect = "copy";
        }

        function drop_handler(ev) {
            ev.preventDefault();
            const data = ev.dataTransfer.getData("text/plain");
            const drop_item_id = document.getElementById(data).id
            const drop_item_orig_parent = document.getElementById(data).parentElement;
            const drop_zone = document.getElementById(ev.target.id);
            // Drop result in ability_drop_zone or results_drop_zone or swap results (prevent dropping multiple in one zone)
            if (drop_item_id.includes("div_final_result")) {

                if (drop_zone.id === "results_drop_zone" || (drop_zone.id.includes("ability_drop_zone") && !drop_zone.querySelector(".ability-drop-item"))) {
                    drop_zone.appendChild(document.getElementById(data));
                }
                else if (drop_zone.id.includes("div_final_result")) {// Dropping onto existing result in any zone will swap values

                    // Swap Results
                    const ability_item_drop_zone = drop_zone.parentElement;
                    drop_item_orig_parent.appendChild(drop_zone);
                    ability_item_drop_zone.appendChild(document.getElementById(data));
                }
                RecalcFinalScores();
            }
        }

        // Increment or Decrement ability with Bonus Points
        function BPchange(ev) {
            const bp_button = document.getElementById(ev.target.id);
            const bp_points = bp_button.parentElement.querySelector(".bp");
            const bp_points_value = parseInt(bp_points.innerText);
            const bp_max = parseInt(span_bp_max.innerText);
            let bp_remaining = parseInt(span_bp_remaining.innerText);

            if (bp_button.id.includes("minus") && bp_points_value > 0) {

                bp_points.innerText = Math.max(0, bp_points_value - 1);
                bp_remaining = (bp_remaining < bp_max ? bp_remaining + 1 : bp_max);
                span_bp_remaining.innerText = bp_remaining;

            } else if (bp_button.id.includes("plus")) {

                bp_points.innerText = (bp_remaining > 0 ? bp_points_value + 1 : bp_points.innerText);
                bp_remaining = (bp_remaining > 0 ? bp_remaining - 1 : 0);
                span_bp_remaining.innerText = bp_remaining;
            }
            RecalcFinalScores();
        }

        function RecalcFinalScores() {

            // Get rows from ability scores table
            const ability_rows = ability_scores.querySelectorAll(".ability-row");
            let over18NotAllowed = ability_scores.dataset.Over18Allowed === "false" && (ability_scores.dataset.distributeresults === "true" || ability_scores.dataset.bonus_points > 0);
            let score_over_18 = false;
            for (let row = 0; row < ability_rows.length; row += 1) {
                const ability_row = document.getElementById(ability_rows[row].id);
                const ability_drop_item = ability_row.querySelector(".ability-drop-zone").querySelector(".ability-drop-item");
                const bonus_points = ability_row.querySelector(".bonus-points").querySelector(".bp");
                const racial_mod = ability_row.querySelector(".racial-mod");
                const final_score_unmod = ability_row.querySelector(".final-score-unmod");
                const final_score_display = ability_row.querySelector(".final-score-display");
                const modifier = ability_row.querySelector(".modifier");

                // Calculate final score
                final_result = parseInt(ability_drop_item ? ability_drop_item.innerText : 0);
                bonus_result = parseInt(bonus_points.innerText);
                racial_mod_result = parseInt(racial_mod.innerText);
                final_score_unmod.value = final_result + bonus_result;// Exclude racial modifiers
                final_score_display.value = final_result + bonus_result + racial_mod_result;

                // Calculate ability modifier
                let ability_mod = 0;
                switch (game.system.id) {
                    case "dnd5e":
                    case "pf1":
                    case "archmage":
                    case "ose":
                        ability_mod = Math.floor((final_score_display.value - 10) / 2);
                        break;
                    case "dcc":
                        ability_mod = CONFIG.DCC.abilities.modifiers[final_score_display.value];
                        break;
                    default:
                        ability_mod = Math.floor((final_score_display.value - 10) / 2);
                }
                modifier.value = (ability_mod > 0 ? "+" : "") + ability_mod;

                // TODO-LOW: Validation for score over 18 is still kinda sucky

                score_over_18 = (final_score_display.value > 18 ? true : score_over_18);
                over18NotAllowed = (final_score_display.value > 18 && over18NotAllowed ? true : over18NotAllowed);
                if (final_score_display.value > 18 && over18NotAllowed) {
                    final_score_display.classList.add("over18");
                } else {
                    final_score_display.classList.remove("over18");
                }
            }

            // Enable/Disable submit Button
            // charactername has nothing to do with scores, I am just being lazy with submit.disable 
            const charactername = document.getElementById("charactername");
            const bp_remaining = parseInt(span_bp_remaining.innerText);
            submit.disabled = (charactername.value.length === 0 || GetNextAbilityDropZone() || bp_remaining > 0 || (score_over_18 && over18NotAllowed));
        }

        async function MoveResult(ev) {
            const result_item = document.getElementById(ev.target.id);
            const results_drop_zone = document.getElementById("results_drop_zone");
            if (result_item.parentElement.id === "results_drop_zone") {
                const next_ability = GetNextAbilityDropZone();
                if (next_ability) {
                    await next_ability.appendChild(result_item);
                }
            }
            else if (results_drop_zone) {
                await results_drop_zone.appendChild(result_item);
            }
            RecalcFinalScores();
        }

        function GetNextAbilityDropZone() {
            const ability_rows = ability_scores.querySelectorAll(".ability-row")
            for (let row = 0; row < ability_rows.length; row += 1) {
                const ability_row = document.getElementById(ability_rows[row].id);
                const ability_drop_zone = ability_row.querySelector(".ability-drop-zone")
                if (ability_drop_zone.innerText === "") {
                    return ability_drop_zone;
                }
            }
            return false;
        }

        function ApplyAsRolled() { // Fires from Hooks.on renderDistributeAbilityScores if ability_scores.dataset.distributeresults === "false"
            const ability_drop_items = results_drop_zone.querySelectorAll(".ability-drop-item");
            for (let item = 0; item < ability_drop_items.length; item += 1) {
                const next_ability = GetNextAbilityDropZone();
                if (next_ability) {
                    ability_drop_items[item].removeAttribute("ondblclick");
                    ability_drop_items[item].removeAttribute("draggable");
                    next_ability.appendChild(ability_drop_items[item]);
                }
            }
            results_drop_zone.innerHTML = "<small><em>" + game.i18n.localize("RNCS.form-app.form-text.applied-as-rolled") + "</em></small>";
            RecalcFinalScores();
        }

        async function UpdateRaceBonus(ev) {
            // Get racial bonuses
            const select = document.getElementById(ev.target.id);
            const jsonDATA = await getJSONData("./modules/roll-new-character-stats/data/character-properties.json");
            let race_bonuses;
            switch (game.system.id) {
                case "dnd5e":
                    race_bonuses = jsonDATA.game_system[0].dnd5e.races[select.selectedIndex]
                    break;
                case "pf1":
                    race_bonuses = jsonDATA.game_system[0].pf1.races[select.selectedIndex]
                    break;
                // case "ose":
                //     race_bonuses = jsonDATA.game_system[0].ose.races[select.selectedIndex]
                //     break;
                // case "archmage":
                //     race_bonuses = jsonDATA.game_system[0].archmage.races[select.selectedIndex]
                //     break;
                default:// Default to dnd5e for now
                    race_bonuses = jsonDATA.game_system[0].dnd5e.races[select.selectedIndex]
            }
            // Update Race Bonus column
            const ability_rows = ability_scores.querySelectorAll(".ability-row")
            for (let row = 0; row < ability_rows.length; row += 1) {
                const ability_row = document.getElementById(ability_rows[row].id);
                const ability_text = ability_row.querySelector(".ability-text").innerText.toLowerCase();
                const racial_mod = ability_row.querySelector(".racial-mod");
                racial_mod.innerText = race_bonuses[ability_text];
            }
            RecalcFinalScores();
        }

        // Had trouble importing json-helper.js to template.
        async function getJSONData(filename) {
            const jsonDATA = await fetch(filename)
                .then(response => response.json())
                .then(data => {
                    return data;
                });
            return jsonDATA;
        }

    </script>

    <div style="margin-bottom:5px;">
        <div class="div_lable">Name:</div>
        <!-- Name has nothing to do with scores, I am just being lazy with submit.disable -->
        <div class="div_user_input">
            <input id="charactername" name="charactername" onchange="RecalcFinalScores()" type="String" value="New Actor" />
        </div>
    </div>

    <div id="race-selector">
        <div class="div_lable">Race:</div>
        <div class="div_user_input">
            <select id="select_race" name="select_race" onchange="UpdateRaceBonus(event)" style="width:100%;">
                {{selectOptions races selected=value nameAttr="race" labelAttr="race"}}
            </select>
        </div>
    </div>

    {{#if occupation}}
    <p style="font-size: small;">
        <span id="occupation" data-occupation="{{occupation}}"></span>
        {{#each equipment_list as |equipment_list id|}}
        <span>Equipment:&nbsp;</span><span>{{equipment_list}}<br></span>
        {{/each}}
        <span>Birth Augur:&nbsp;</span><span>{{luck}}</span>            
    </p>
    {{/if}}

        <table id="results-table">
            <tr>
                <td class="results-header">Results:</td>
                <td id="results_drop_zone" class="results-drop-zone" ondrop="drop_handler(event)"
                    ondragover="dragover_handler(event)">
                    {{#each final_results as |final_results id| }}
                    <div id="div_final_result{{id}}" class="ability-drop-item" ondblclick="MoveResult(event)"
                        draggable="true">
                        {{final_results}}
                    </div>
                    {{/each}}
                </td>
            </tr>
        </table>

        <table id="ability_scores" data-Over18Allowed={{Over18Allowed}} data-distributeresults={{DistributeResults}}
            data-bonus_points={{bonus_points}} data-hideresultszone={{HideResultsZone}}>
            <tr id="header_row" class="header-row">
                <th>Ability</th>
                <th>Result</th>
                <th>Bonus&nbsp;</span><span id="span_bp_remaining">{{bonus_points}}</span>/<span
                        id="span_bp_max">{{bonus_points}}</span></th>
                <th class="race-mod-header">Race Bonus</th>
                <th>Score
                    {{#if_AorB DistributeResults bonus_points}}
                    {{#unless Over18Allowed}}
                    <span style="font-size: small;">
                        *
                    </span>
                    {{/unless}}
                    {{/if_AorB}}
                </th>
                <th class="modifier-header">Mod</th>
            </tr>
            {{#each abilities as |abilities id|}}
            <tr id="{{abilities}}_row" class="ability-row">
                <td class="ability-text">{{abilities}}</td>
                <td id="{{abilities}}_ability_drop_zone" class="ability-drop-zone" title="drop result here"
                    ondrop="drop_handler(event)" ondragover="dragover_handler(event)">
                </td>
                <td class="bonus-points"><span id="{{abilities}}_bp_minus" class="bp-button bp-button-minus"
                        onclick="BPchange(event)">-</span><span class="bp">0</span><span id="{{abilities}}_bp_plus"
                        class="bp-button bp-button-plus" onclick="BPchange(event)">+</span></td>
                <td id="{{abilities}}_racial_mod" class="racial-mod">0</td>
                <td id="{{abilities}}_final_score">
                    <input name="{{abilities}}_final_score_unmod" class="final-score-unmod" value="0" />
                    <input name="{{abilities}}_final_score_display" class="final-score-display" value="0" />
                </td>
                <td id="{{abilities}}_mod"><input name="{{abilities}}_modifier" class="modifier" value="-5" /></td>
            </tr>
            {{/each}}
        </table>

        <button type="submit" id="submit" disabled>
            <i class="fa fa-check"></i> {{localize "RNCS.form-app.form-text.accept-new-actor"}}
        </button>

        {{#if_AorB DistributeResults bonus_points}}
        {{#unless Over18Allowed}}
        <span style="font-size: small;">
            {{localize "RNCS.form-app.form-text.over-18-not-allowed"}}
        </span>
        {{/unless}}
        {{/if_AorB}}

</form>